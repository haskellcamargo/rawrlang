module Data:
  with .Closure
  with .Countable
  with .Exception
  with .ReflectionClass
  import Data.Types

  define allowAccess
    return True
  end

  define map (fn :: Closure, xs :: array)
    let arr = []
    iterate xs as item
      arr[] = ~fn item
    end
    return arr
  end

  define each (fn :: Closure, xs :: array)
    iterate xs as item
      ~fn item
    return xs
  end

  define filter (fn :: Closure, xs :: array)
    let arr = []
    iterate xs as item
      arr[] = item if ~fn item
    end
  end

  blueprint ClassHolder
    with contract Countable

    my publicMethods = 0
    my methods       = null

    method constructor (className)
      if ~class_exists className
        let reflectionClass = +ReflectionClass className
      otherwise
        raise +Exception "Class '${className}' not found."
      end
    end

    method count then return @publicMethods

    method listMethods then return @methods

    method listPublicMethods
      return @methods
      >> filter (.isPublic!)
    end

    static method parseDocComments (doc)
      let [doc, res] = [doc / "\n" ; []]
      iterate doc as line
        let line = ~trim line

        if line like "/**" or line like "*/"
          loop
        end

        if line.0 like "*"
          let simpleData = "/\*\s*@([a-z\|]+)\s*:\s*(.*)/"
          let out
          let matching = ~preg_match simpleData, line, out
          if matching
            res[] = [out.1 ; out.2]
          end
          loop
        end
        raise +Exception "Expecting '*' as the first character of line."
      end
      return res
    end
  end

  record Name { name, class, type, about }

  let methodList = []

  data !! "num" = +ClassHolder "\\Data\\Num"

  (data !! "num").listPublicMethods!
  >> filter (m :: ReflectionFunction) -> return m.getDocComment!
  >> each (item) -> var_dump ~ClassHolder::parseDocComments item.getDocComment!

end
