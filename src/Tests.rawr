namespace Data
  with ~Closure
  with ~Countable
  with ~Exception
  with ~ReflectionClass
  import Data.Types

  defun map = (fn :: Closure, xs :: array)
    let arr = []
    iterate xs as item
      arr[] = fn item
    end
    return arr
  end

  defun each (fn :: Closure, xs :: array)
    iterate xs as item
      fn item
    return xs
  end

  defun filter (fn :: Closure, xs :: array)
    let arr = []
    iterate list as item
      arr[] = item if fn item
    end
  end

  class ClassHolder
    with contract Countable

    my publicMethods = 0
    my methods       = null

    method constructor (className)
      if class_exists className
        let reflectionClass = new ReflectionClass className
      otherwise
        raise +Exception "Class '${className}' not found."
      end
    end

    method count then return @publicMethods

    method listMethods then return @methods

    method listPublicMethods
      return @methods
      |> filter (.isPublic!)
    end

    static method parseDocComments (doc)
      let [doc, res] = [doc / "\n" ; []]
      iterate doc as line
        let line = trim line

        if line like "/**" or line like "*/"
          continue
        end

        if line.0 like "*"
          let simpleData = /\*\s*@([a-z\|]+)\s*:\s*(.*)/
          let out
          let matching = preg_match simpleData, line, out
          if matching
            res[] = [out.1 ; out.2]
          end
          continue
        end
        raise +Exception "Expecting '*' as the first character of line."
      end
      return res
    end
  end

  record Name { name, $class, type, about }

  let methodList = []

  data["num"] = +ClassHolder "\\Data\\Num"

  data["num"].listPublicMethods!
  |> filter (ReflectionMethod method) -> return method.getDocComment!
  |> each (item) -> var_dump ClassHolder::parseDocComments item.getDocComment!

end